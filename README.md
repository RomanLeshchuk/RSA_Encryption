8<h1>RSA Encryption Algorithm</h1>

<h2>Опис проєкту</h2>

Цей проєкт реалізує базову версію алгоритму шифрування RSA на Python. Мета — зрозуміти, як працює криптографічна система з відкритим ключем, реалізувавши генерацію ключів, шифрування та дешифрування текстових повідомлень.
Структура проєкту

<b>generate_keys.py</b> — модуль для генерації пари ключів (приватного та публічного).

<b>encryption.py</b> — модуль, який реалізує шифрування та дешифрування повідомлень.

<b>server.py</b> — модуль, який запускає сервер, обробляє підключення користувачів та їх взаємодію.

<b>client.py</b> — модуль, який створює нового клієнта, який обробляється сервером та може взаємодіяти з іншими.

<h2>Опис реалізації</h2>

<h3>Генерація ключів</h3>

Генерація простих чисел: функція generate_large_prime(bits) генерує прості числа заданої бітової довжини, використовуючи secrets.randbits і перевірку на простоту (is_prime(n) реалізовану шляхом перевірки всіх чисел від 2 до √n на те чи не ділять води задане число націло).

<h3>Розрахунок відкритого та закритого ключа</h3>

n=p⋅q, де p та q - згенеровані випадкові прості числа.

ϕ(n)=(p−1)(q−1)

Підбирається значення e, взаємно просте з ϕ(n), для цього шукаємо всі взаємно прості числа з числом ϕ(n) на проміжку ϕ(n)/2 до ϕ(n)/4, та вибираємо випадкове з них усіх. Саме такий проміжок пошуку було реалізовано для покращення швидкості виконання

Використовується алгоритм Евкліда (extended_gcd) для знаходження d - числа оберненого до е за модулем ϕ(n)

Повертається пара ключів: (private_key, public_key) де private_key - (d, n), а public_key - (e, n)

<h3>Шифрування та дешифрування</h3>

Шифрування: кожен символ повідомлення переводиться в ASCII-код, підноситься до степеня e та береться за модулем n.

Дешифрування: зашифровані числа підносяться до степеня d та беруться за модулем n, після чого переводяться назад у символи.

Формат збереження: повідомлення кодуються у вигляді чисел, розділених комами.

<h3>Підключення сервера</h3>

Спершу запускається сам сервер за певною адресою, а також генерується пара ключів для сервера - приватний і публічний.

Також підтримується список всіх клієнтів, спочатку він пустий.

<h3>Підключення клієнта</h3>

Коли запускається новий клієнт, то він також створює для себе пару ключів. Тоді необхідно здійснити обмін ключами з сервером.

<h3>Обмін ключами</h3>

Спершу сервер надсилає новому клієнту свій публічний ключ, клієнт його зберігає. Тоді клієнт також надсилає серверу свій публічний ключ.

Тоді сервер шифрує свій приватний ключ публічним ключем клієнта і надсилає йому цей зашифрований приватний ключ. Клієнт може його розшифрувати, адже має свій приватний ключ-дишифратор, тож тепер також має приватний ключ сервера.

Отже, тепер кожен клієнт і сервер мають однакові приватні і однакові публічні ключі (ті, які початково генерував сервер).

<h3>Взаємодія між клієнтом і сервером</h3>

Коли клієнт хоче відправити повідомлення, він спершу його шифрує публічним ключем, а тоді надсилає серверу.

Тоді сервер надсилає це повідомлення усім іншим користувачам у такому ж зашифрованому вигляді.

І вже тоді кожен клієнт, який отримав це повідомлення, розшифровує його для себе приватним ключем.

Окрім того, сервер може надсилати клієнтам деякі технічні повідомлення (наприклад, що новий користувач приєднався), шифруючи його в себе, а тоді кожен клієнт його розшифровує в себе.

<h3>Перевірка повідомлення на цілісність</h3>

Існує небезпека, що повідомлення може бути перехоплене і змінене, хай навіть у зашифрованому вигляді.

Щоб виявити це, при перед кожним шифруванням також генерується хеш повідомлення, який має таку властивість, що для різних повідомлень він практично завжди буде різним. Тоді, після передачі зашифрованого повідомлення та хешу, одержувач може його розшифрувати та перевірити, чи збігається хеш розшифрованого повідомлення із отриманим хешом. Якщо так, то можна майже зі стовідсотковою ймовірністю стверджувати, що повідомлення не було змінене, інакше його було перехоплено і змінено.

<h2>Розподіл роботи</h2>
Максимчук Іван: генерація ключів та шифрування/дешифрування


Лещук Роман: Підключення клієнта, підключення сервера, обмін ключами, взаємодія клієнта та сервера, перевірка повідомлення на цілісність